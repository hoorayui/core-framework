package i18n

import (
	"fmt"
	"framework/util"
	"html/template"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/BurntSushi/toml"
	"github.com/dave/jennifer/jen"
	"golang.org/x/text/language"
)

// GenFileExt ...
const GenFileExt = ".i18n.go"

// TranslatorFileName ...
const TranslatorFileName = "_tr.i18n.go"

type langMapping map[string]map[string]string

// GenerateTranslatorCode generates translator
func GenerateTranslatorCode(workdir ...string) {
	if len(workdir) == 0 {
		workdir = []string{"./"}
	}
	wd := workdir[0]
	fileInfos, err := ioutil.ReadDir(wd)
	if err != nil {
		log.Fatalf("failed to ReadDir[%s]: %s", workdir, err.Error())
	}
	absPath, err := filepath.Abs(wd)
	if err != nil {
		log.Fatalf("failed to get abs dir for[%s]: %s", workdir, err.Error())
	}
	pathSplit := strings.Split(absPath, string(filepath.Separator))
	if len(pathSplit) < 2 {
		log.Fatalf("invalid file path for %s", absPath)
	}
	packageName := pathSplit[len(pathSplit)-1]
	generateTranslator(absPath, packageName)
	for _, info := range fileInfos {
		if !info.IsDir() && strings.HasSuffix(info.Name(), ".toml") {
			generateLangFromToml(absPath, packageName, info)
		}
	}
	generateConstants(absPath, packageName)
}

func generateTranslator(workdir, packageName string) {
	translatorFileName := filepath.Join(workdir, packageName+TranslatorFileName)
	t, err := template.New("tr").Parse(trTemplate)
	if err != nil {
		log.Fatalf("error parse template: %s", err.Error())
	}
	os.Remove(translatorFileName)
	f, err := os.OpenFile(translatorFileName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o644)
	if err != nil {
		log.Fatalf("error OpenFile[%s]: %s", TranslatorFileName, err.Error())
	}
	defer func() {
		f.Close()
		if err != nil {
			os.Remove(translatorFileName)
			log.Fatalf("error Close file: %s", err.Error())
		}
	}()
	err = t.Execute(f, struct {
		PackageName string
		GenTime     template.HTML
	}{packageName, template.HTML(util.Now().String())})
	if err != nil {
		os.Remove(translatorFileName)
		log.Fatalf("error ExecuteTemplate: %s", err.Error())
	}
}

// id + language duplicate check
var idLangDupMap map[string]interface{}

// all id map for constant generation
// id-comments
var idMap map[string]string

var supportLanguages map[string]interface{}

func init() {
	idLangDupMap = make(map[string]interface{})
	idMap = make(map[string]string)
	supportLanguages = make(map[string]interface{})
}

func generateConstants(workdir, packageName string) {
	f := jen.NewFile(packageName)
	f.PackageComment(fmt.Sprintf("generated by cap, DO NOT EDIT."))
	newFile := filepath.Join(workdir, "consts"+GenFileExt)
	// support languages
	f.Comment("supported languages:")
	languageArray := []jen.Code{}
	for sl := range supportLanguages {
		constName := "Lang_" + strings.Replace(sl, "-", "", -1)
		languageArray = append(languageArray, jen.Id(constName))
		f.Var().Add(
			jen.Id(constName).Op("=").Qual("golang.org/x/text/language", "Make").Call(jen.Lit(sl)),
		)
	}

	// language matcher
	languageMatcherName := "languageMatcher"

	f.Var().Id(languageMatcherName).Op("=").Qual("golang.org/x/text/language", "NewMatcher").
		Call(jen.Index().Qual("golang.org/x/text/language", "Tag").Values(languageArray...))

	f.Comment("language matcher")
	f.Func().Id("MatchLang").Params(jen.Id("lang").String()).Params(jen.Id("tag").Qual("golang.org/x/text/language", "Tag"), jen.Err().Id("error")).
		Block(
			jen.Id("langTag").Op(":=").Qual("golang.org/x/text/language", "Make").Call(jen.Id("lang")),
			jen.List(jen.Id("matchedTag"), jen.Id("_"), jen.Id("c")).Op(":=").Id(languageMatcherName).Dot("Match").Call(jen.Id("langTag")),
			jen.If(jen.Id("c").Op("<").Qual("golang.org/x/text/language", "High")).Block(
				jen.Return(jen.Id("matchedTag"), jen.Qual("fmt", "Errorf").Call(jen.Lit("no confidence language matched"))),
			),
			jen.Return(jen.Id("matchedTag"), jen.Nil()),
		)

	idArray := make([]string, len(idMap))
	// constants
	f.Comment("language id definitions:")
	// constDeclar := make([]jen.Code, len(idMap))
	index := 0
	for k := range idMap {
		idArray[index] = k
		index++
	}
	sort.Slice(idArray, func(i, j int) bool { return idArray[i] < idArray[j] })
	for _, k := range idArray {
		f.Comment(k + " " + idMap[k])
		f.Const().Id(k).Op("=").Qual("framework/pkg/cap/msg/i18n", "TrID").Call(jen.Lit("v_" + packageName + "_" + k))
	}
	// f.Add(jen.Const().Defs(constDeclar...))
	os.Remove(newFile)
	err := f.Save(newFile)
	if err != nil {
		log.Fatal(err)
	}
}

func generateLangFromToml(workdir, packageName string, tf os.FileInfo) {
	fileName := tf.Name()
	fileExt := filepath.Ext(fileName)
	fileNameWithoutExt := fileName[0 : len(fileName)-len(fileExt)]

	lm := langMapping{}
	_, err := toml.DecodeFile(fileName, &lm)
	if err != nil {
		log.Fatalf("failed to DecodeFile[%s]: %s", fileName, err.Error())
	}

	f := jen.NewFile(packageName)
	f.PackageComment(fmt.Sprintf("Code generated by cap from [%s] at [%s], DO NOT EDIT.", fileName, util.Now().String()))
	newFile := filepath.Join(workdir, fileNameWithoutExt+GenFileExt)
	initFuncBlock := []jen.Code{
		jen.Id("initTrRegistry").Call(),
	}
	// parse toml
	for id, ls := range lm {
		idMap[id] = ""
		for l, v := range ls {
			supportLanguages[l] = nil
			dk := id + "#" + l
			if _, ok := idLangDupMap[dk]; ok {
				log.Fatalf("dupplicate translation for [%s]", dk)
			}
			idLangDupMap[dk] = nil
			if l == "zh-CN" {
				idMap[id] = v
			}
			tag, err := language.Parse(l)
			if err != nil {
				log.Fatalf("failed to parse[%s]: %s", l, err.Error())
			}
			initFuncBlock = append(initFuncBlock, jen.Id(packageName+"_lr").Dot("addTranslation").
				Call(jen.Id(id), jen.Qual("golang.org/x/text/language", "Make").Call(jen.Lit(tag.String())), jen.Lit(v)))
		}
	}

	f.Add(jen.Func().Id("init").Params().Block(initFuncBlock...))
	os.Remove(newFile)
	err = f.Save(newFile)
	if err != nil {
		log.Fatal(err)
	}
}

var trTemplate = `
// generated by cap at {{.GenTime}}, DO NOT EDIT.
package {{.PackageName}}

import (
	"fmt"

	"framework/pkg/cap/msg/i18n"
	"golang.org/x/text/language"
)

var {{.PackageName}}_lr {{.PackageName}}_langRegistry

func initTrRegistry() {
	if {{.PackageName}}_lr == nil {
		{{.PackageName}}_lr = {{.PackageName}}_langRegistry{}
	}
}

func (l {{.PackageName}}_langRegistry) addTranslation(id i18n.TrID, lang language.Tag, translation string) error {
	if ts, ok := {{.PackageName}}_lr[id]; ok {
		if _, ok := ts[lang]; ok {
			return fmt.Errorf("dupplicate translation for [%s#%s]", id, lang.String())
		}
		l[id][lang] = translation
	} else {
		l[id] = map[language.Tag]string{
			lang: translation,
		}
	}
	return nil
}

func init() {
	i18n.AddTrCandidates(&{{.PackageName}}_tr{})
}

// map[langID]map[langCode]translation
type {{.PackageName}}_langRegistry map[i18n.TrID]map[language.Tag]string

type {{.PackageName}}_tr struct {
}

func (t *{{.PackageName}}_tr) Translate(lang language.Tag, id i18n.TrID, args ...interface{}) (string, error) {
	if ts, ok := {{.PackageName}}_lr[id]; ok {
		if t, ok := ts[lang]; ok {
			return fmt.Sprintf(t, args...), nil
		}
	}
	return "", i18n.ErrNoTranslateCandidate
}
`
